// HandwritingRecognizer_Internal.java is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     third_party/blink/public/mojom/handwriting/handwriting.mojom
//

package org.chromium.handwriting.mojom;

class HandwritingRecognizer_Internal {

  public static final org.chromium.mojo.bindings.Interface.Manager<
          HandwritingRecognizer, HandwritingRecognizer.Proxy>
      MANAGER =
          new org.chromium.mojo.bindings.Interface.Manager<
              HandwritingRecognizer, HandwritingRecognizer.Proxy>() {

            @Override
            public String getName() {
              return "handwriting.mojom.HandwritingRecognizer";
            }

            @Override
            public int getVersion() {
              return 0;
            }

            @Override
            public Proxy buildProxy(
                org.chromium.mojo.system.Core core,
                org.chromium.mojo.bindings.MessageReceiverWithResponder messageReceiver) {
              return new Proxy(core, messageReceiver);
            }

            @Override
            public Stub buildStub(org.chromium.mojo.system.Core core, HandwritingRecognizer impl) {
              return new Stub(core, impl);
            }

            @Override
            public HandwritingRecognizer[] buildArray(int size) {
              return new HandwritingRecognizer[size];
            }
          };

  private static final int GET_PREDICTION_ORDINAL = 0;

  static final class Proxy extends org.chromium.mojo.bindings.Interface.AbstractProxy
      implements HandwritingRecognizer.Proxy {

    Proxy(
        org.chromium.mojo.system.Core core,
        org.chromium.mojo.bindings.MessageReceiverWithResponder messageReceiver) {
      super(core, messageReceiver);
    }

    @Override
    public void getPrediction(
        HandwritingStroke[] strokes, HandwritingHints hints, GetPrediction_Response callback) {

      HandwritingRecognizerGetPredictionParams _message =
          new HandwritingRecognizerGetPredictionParams();

      _message.strokes = strokes;

      _message.hints = hints;

      getProxyHandler()
          .getMessageReceiver()
          .acceptWithResponder(
              _message.serializeWithHeader(
                  getProxyHandler().getCore(),
                  new org.chromium.mojo.bindings.MessageHeader(
                      GET_PREDICTION_ORDINAL,
                      org.chromium.mojo.bindings.MessageHeader.MESSAGE_EXPECTS_RESPONSE_FLAG,
                      0)),
              new HandwritingRecognizerGetPredictionResponseParamsForwardToCallback(callback));
    }
  }

  static final class Stub extends org.chromium.mojo.bindings.Interface.Stub<HandwritingRecognizer> {

    Stub(org.chromium.mojo.system.Core core, HandwritingRecognizer impl) {
      super(core, impl);
    }

    @Override
    public boolean accept(org.chromium.mojo.bindings.Message message) {
      try {
        org.chromium.mojo.bindings.ServiceMessage messageWithHeader = message.asServiceMessage();
        org.chromium.mojo.bindings.MessageHeader header = messageWithHeader.getHeader();
        int flags = org.chromium.mojo.bindings.MessageHeader.NO_FLAG;
        if (header.hasFlag(org.chromium.mojo.bindings.MessageHeader.MESSAGE_IS_SYNC_FLAG)) {
          flags = flags | org.chromium.mojo.bindings.MessageHeader.MESSAGE_IS_SYNC_FLAG;
        }
        if (!header.validateHeader(flags)) {
          return false;
        }
        switch (header.getType()) {
          case org.chromium.mojo.bindings.interfacecontrol.InterfaceControlMessagesConstants
              .RUN_OR_CLOSE_PIPE_MESSAGE_ID:
            return org.chromium.mojo.bindings.InterfaceControlMessagesHelper.handleRunOrClosePipe(
                HandwritingRecognizer_Internal.MANAGER, messageWithHeader);

          default:
            return false;
        }
      } catch (org.chromium.mojo.bindings.DeserializationException e) {
        System.err.println(e.toString());
        return false;
      }
    }

    @Override
    public boolean acceptWithResponder(
        org.chromium.mojo.bindings.Message message,
        org.chromium.mojo.bindings.MessageReceiver receiver) {
      try {
        org.chromium.mojo.bindings.ServiceMessage messageWithHeader = message.asServiceMessage();
        org.chromium.mojo.bindings.MessageHeader header = messageWithHeader.getHeader();
        int flags = org.chromium.mojo.bindings.MessageHeader.MESSAGE_EXPECTS_RESPONSE_FLAG;
        if (header.hasFlag(org.chromium.mojo.bindings.MessageHeader.MESSAGE_IS_SYNC_FLAG)) {
          flags = flags | org.chromium.mojo.bindings.MessageHeader.MESSAGE_IS_SYNC_FLAG;
        }
        if (!header.validateHeader(flags)) {
          return false;
        }
        switch (header.getType()) {
          case org.chromium.mojo.bindings.interfacecontrol.InterfaceControlMessagesConstants
              .RUN_MESSAGE_ID:
            return org.chromium.mojo.bindings.InterfaceControlMessagesHelper.handleRun(
                getCore(), HandwritingRecognizer_Internal.MANAGER, messageWithHeader, receiver);

          case GET_PREDICTION_ORDINAL:
            {
              HandwritingRecognizerGetPredictionParams data =
                  HandwritingRecognizerGetPredictionParams.deserialize(
                      messageWithHeader.getPayload());

              getImpl()
                  .getPrediction(
                      data.strokes,
                      data.hints,
                      new HandwritingRecognizerGetPredictionResponseParamsProxyToResponder(
                          getCore(), receiver, header.getRequestId()));
              return true;
            }

          default:
            return false;
        }
      } catch (org.chromium.mojo.bindings.DeserializationException e) {
        System.err.println(e.toString());
        return false;
      }
    }
  }

  static final class HandwritingRecognizerGetPredictionParams
      extends org.chromium.mojo.bindings.Struct {

    private static final int STRUCT_SIZE = 24;
    private static final org.chromium.mojo.bindings.DataHeader[] VERSION_ARRAY =
        new org.chromium.mojo.bindings.DataHeader[] {
          new org.chromium.mojo.bindings.DataHeader(24, 0)
        };
    private static final org.chromium.mojo.bindings.DataHeader DEFAULT_STRUCT_INFO =
        VERSION_ARRAY[0];
    public HandwritingStroke[] strokes;
    public HandwritingHints hints;

    private HandwritingRecognizerGetPredictionParams(int version) {
      super(STRUCT_SIZE, version);
    }

    public HandwritingRecognizerGetPredictionParams() {
      this(0);
    }

    public static HandwritingRecognizerGetPredictionParams deserialize(
        org.chromium.mojo.bindings.Message message) {
      return decode(new org.chromium.mojo.bindings.Decoder(message));
    }

    /**
     * Similar to the method above, but deserializes from a |ByteBuffer| instance.
     *
     * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
     */
    public static HandwritingRecognizerGetPredictionParams deserialize(java.nio.ByteBuffer data) {
      return deserialize(
          new org.chromium.mojo.bindings.Message(
              data, new java.util.ArrayList<org.chromium.mojo.system.Handle>()));
    }

    @SuppressWarnings("unchecked")
    public static HandwritingRecognizerGetPredictionParams decode(
        org.chromium.mojo.bindings.Decoder decoder0) {
      if (decoder0 == null) {
        return null;
      }
      decoder0.increaseStackDepth();
      HandwritingRecognizerGetPredictionParams result;
      try {
        org.chromium.mojo.bindings.DataHeader mainDataHeader =
            decoder0.readAndValidateDataHeader(VERSION_ARRAY);
        final int elementsOrVersion = mainDataHeader.elementsOrVersion;
        result = new HandwritingRecognizerGetPredictionParams(elementsOrVersion);
        {
          org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(8, false);
          {
            org.chromium.mojo.bindings.DataHeader si1 =
                decoder1.readDataHeaderForPointerArray(
                    org.chromium.mojo.bindings.BindingsHelper.UNSPECIFIED_ARRAY_LENGTH);
            result.strokes = new HandwritingStroke[si1.elementsOrVersion];
            for (int i1 = 0; i1 < si1.elementsOrVersion; ++i1) {

              org.chromium.mojo.bindings.Decoder decoder2 =
                  decoder1.readPointer(
                      org.chromium.mojo.bindings.DataHeader.HEADER_SIZE
                          + org.chromium.mojo.bindings.BindingsHelper.POINTER_SIZE * i1,
                      false);
              result.strokes[i1] = HandwritingStroke.decode(decoder2);
            }
          }
        }
        {
          org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(16, false);
          result.hints = HandwritingHints.decode(decoder1);
        }

      } finally {
        decoder0.decreaseStackDepth();
      }
      return result;
    }

    @SuppressWarnings("unchecked")
    @Override
    public final void encode(org.chromium.mojo.bindings.Encoder encoder) {
      org.chromium.mojo.bindings.Encoder encoder0 =
          encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO);

      if (this.strokes == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        org.chromium.mojo.bindings.Encoder encoder1 =
            encoder0.encodePointerArray(
                this.strokes.length,
                8,
                org.chromium.mojo.bindings.BindingsHelper.UNSPECIFIED_ARRAY_LENGTH);
        for (int i0 = 0; i0 < this.strokes.length; ++i0) {

          encoder1.encode(
              this.strokes[i0],
              org.chromium.mojo.bindings.DataHeader.HEADER_SIZE
                  + org.chromium.mojo.bindings.BindingsHelper.POINTER_SIZE * i0,
              false);
        }
      }

      encoder0.encode(this.hints, 16, false);
    }
  }

  static final class HandwritingRecognizerGetPredictionResponseParams
      extends org.chromium.mojo.bindings.Struct {

    private static final int STRUCT_SIZE = 16;
    private static final org.chromium.mojo.bindings.DataHeader[] VERSION_ARRAY =
        new org.chromium.mojo.bindings.DataHeader[] {
          new org.chromium.mojo.bindings.DataHeader(16, 0)
        };
    private static final org.chromium.mojo.bindings.DataHeader DEFAULT_STRUCT_INFO =
        VERSION_ARRAY[0];
    public HandwritingPrediction[] prediction;

    private HandwritingRecognizerGetPredictionResponseParams(int version) {
      super(STRUCT_SIZE, version);
    }

    public HandwritingRecognizerGetPredictionResponseParams() {
      this(0);
    }

    public static HandwritingRecognizerGetPredictionResponseParams deserialize(
        org.chromium.mojo.bindings.Message message) {
      return decode(new org.chromium.mojo.bindings.Decoder(message));
    }

    /**
     * Similar to the method above, but deserializes from a |ByteBuffer| instance.
     *
     * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
     */
    public static HandwritingRecognizerGetPredictionResponseParams deserialize(
        java.nio.ByteBuffer data) {
      return deserialize(
          new org.chromium.mojo.bindings.Message(
              data, new java.util.ArrayList<org.chromium.mojo.system.Handle>()));
    }

    @SuppressWarnings("unchecked")
    public static HandwritingRecognizerGetPredictionResponseParams decode(
        org.chromium.mojo.bindings.Decoder decoder0) {
      if (decoder0 == null) {
        return null;
      }
      decoder0.increaseStackDepth();
      HandwritingRecognizerGetPredictionResponseParams result;
      try {
        org.chromium.mojo.bindings.DataHeader mainDataHeader =
            decoder0.readAndValidateDataHeader(VERSION_ARRAY);
        final int elementsOrVersion = mainDataHeader.elementsOrVersion;
        result = new HandwritingRecognizerGetPredictionResponseParams(elementsOrVersion);
        {
          org.chromium.mojo.bindings.Decoder decoder1 = decoder0.readPointer(8, true);
          if (decoder1 == null) {
            result.prediction = null;
          } else {
            org.chromium.mojo.bindings.DataHeader si1 =
                decoder1.readDataHeaderForPointerArray(
                    org.chromium.mojo.bindings.BindingsHelper.UNSPECIFIED_ARRAY_LENGTH);
            result.prediction = new HandwritingPrediction[si1.elementsOrVersion];
            for (int i1 = 0; i1 < si1.elementsOrVersion; ++i1) {

              org.chromium.mojo.bindings.Decoder decoder2 =
                  decoder1.readPointer(
                      org.chromium.mojo.bindings.DataHeader.HEADER_SIZE
                          + org.chromium.mojo.bindings.BindingsHelper.POINTER_SIZE * i1,
                      false);
              result.prediction[i1] = HandwritingPrediction.decode(decoder2);
            }
          }
        }

      } finally {
        decoder0.decreaseStackDepth();
      }
      return result;
    }

    @SuppressWarnings("unchecked")
    @Override
    public final void encode(org.chromium.mojo.bindings.Encoder encoder) {
      org.chromium.mojo.bindings.Encoder encoder0 =
          encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO);

      if (this.prediction == null) {
        encoder0.encodeNullPointer(8, true);
      } else {
        org.chromium.mojo.bindings.Encoder encoder1 =
            encoder0.encodePointerArray(
                this.prediction.length,
                8,
                org.chromium.mojo.bindings.BindingsHelper.UNSPECIFIED_ARRAY_LENGTH);
        for (int i0 = 0; i0 < this.prediction.length; ++i0) {

          encoder1.encode(
              this.prediction[i0],
              org.chromium.mojo.bindings.DataHeader.HEADER_SIZE
                  + org.chromium.mojo.bindings.BindingsHelper.POINTER_SIZE * i0,
              false);
        }
      }
    }
  }

  static class HandwritingRecognizerGetPredictionResponseParamsForwardToCallback
      extends org.chromium.mojo.bindings.SideEffectFreeCloseable
      implements org.chromium.mojo.bindings.MessageReceiver {
    private final HandwritingRecognizer.GetPrediction_Response mCallback;

    HandwritingRecognizerGetPredictionResponseParamsForwardToCallback(
        HandwritingRecognizer.GetPrediction_Response callback) {
      this.mCallback = callback;
    }

    @Override
    public boolean accept(org.chromium.mojo.bindings.Message message) {
      try {
        org.chromium.mojo.bindings.ServiceMessage messageWithHeader = message.asServiceMessage();
        org.chromium.mojo.bindings.MessageHeader header = messageWithHeader.getHeader();
        if (!header.validateHeader(
            GET_PREDICTION_ORDINAL,
            org.chromium.mojo.bindings.MessageHeader.MESSAGE_IS_RESPONSE_FLAG)) {
          return false;
        }

        HandwritingRecognizerGetPredictionResponseParams response =
            HandwritingRecognizerGetPredictionResponseParams.deserialize(
                messageWithHeader.getPayload());

        mCallback.call(response.prediction);
        return true;
      } catch (org.chromium.mojo.bindings.DeserializationException e) {
        return false;
      }
    }
  }

  static class HandwritingRecognizerGetPredictionResponseParamsProxyToResponder
      implements HandwritingRecognizer.GetPrediction_Response {

    private final org.chromium.mojo.system.Core mCore;
    private final org.chromium.mojo.bindings.MessageReceiver mMessageReceiver;
    private final long mRequestId;

    HandwritingRecognizerGetPredictionResponseParamsProxyToResponder(
        org.chromium.mojo.system.Core core,
        org.chromium.mojo.bindings.MessageReceiver messageReceiver,
        long requestId) {
      mCore = core;
      mMessageReceiver = messageReceiver;
      mRequestId = requestId;
    }

    @Override
    public void call(HandwritingPrediction[] prediction) {
      HandwritingRecognizerGetPredictionResponseParams _response =
          new HandwritingRecognizerGetPredictionResponseParams();

      _response.prediction = prediction;

      org.chromium.mojo.bindings.ServiceMessage _message =
          _response.serializeWithHeader(
              mCore,
              new org.chromium.mojo.bindings.MessageHeader(
                  GET_PREDICTION_ORDINAL,
                  org.chromium.mojo.bindings.MessageHeader.MESSAGE_IS_RESPONSE_FLAG,
                  mRequestId));
      mMessageReceiver.accept(_message);
    }
  }
}
